# このドキュメントを読む人に向けて。
要件に明記されておらず、もしも仕様に含めるなら要件に書く必要があるぐらい機能として分離されていると感じたため、
bashの機能としてデフォルトで実装されているものうち、以下の文章に関する情報は削除されています。

* posix モードに関すること。特にBASH_ENV付近。
* 起動ファイル(.bashrc)等に関して。

# 書式
bash
# 説明
bash は、標準入力やファイルから読み込んだコマンドを実行する、 sh 互換のコマンド言語インタプリタです。 bash には、Korn シェルや C シェル (ksh や csh) の便利な機能も採り入れられています。
bash は IEEE POSIX specification (IEEE Standard 1003.1) の Shell and Utilities に準拠する実装を目指しています。 bash はデフォルトで POSIX 準拠に設定することもできます。
# 起動

対話的なシェルとは、 オプションでない引き数がなく、 標準入力と標準エラー出力がいずれも端末に接続されていて (これは isatty(3) で調べられます)、起動されたシェルのことです。 bash が対話的に動作している場合には、 PS1 が設定されます。

# 定義
このドキュメントの残りの部分では、 以下の定義を使用します。

**ブランク (blank)**
空白文字またはタブ文字
**単語 (word)**
シェルが 1 単位とみなす文字の並び。 トークン (token) とも言われます。
**名前 (name)**
英数字とアンダースコア文字だけから構成され、 かつ最初の文字が英字かアンダースコア文字である 単語。 識別子 (identifier) とも言われます。
**メタ文字 (metacharacter)**
クォートされていない場合に、単語区切りとなる文字。 以下の文字のうちのいずれかです:
```
| & ; ( ) < > space tab
```

**制御演算子 (control operator)**
制御機能を持つ トークン。 以下のシンボルのうちのいずれかです:
```
|| & && ; ;; ( ) | |& <newline>
```

# シェルの文法
単純なコマンド (Simple Commands)
単純なコマンド (simple command) とは、 変数の代入を並べたもの (これは省略可能です) の後に、 ブランク区切りの単語とリダイレクションを記述し、 最後に制御演算子を置いたものです。 最初の単語は実行するコマンドを指定します。 これは 0 番目の引き数となります。 残りの単語は起動されるコマンドに引き数として渡されます。

単純なコマンドの返り値はコマンドの終了コードですが、シグナル n を受けてコマンドが終了した場合には 128+n となります。

パイプライン (Pipeline)


command の標準出力は command2 の標準入力にパイプで接続されます。 この接続は、 コマンドで指定したどのリダイレクションよりも先に実行されます (後述の リダイレクト を参照)。

パイプラインの返却ステータスは最後のコマンドの終了ステータスになります。

パイプライン中の各コマンドは、それぞれ別のプロセスとして (つまりサブシェル内で) 実行されます。

# リスト

リスト演算子のうち、 && と || の優先順位は同じです。

リスト 中では、コマンドの区切りとして、 セミコロンの代わりに一つ以上の改行が使われることもあります。

シェルはそれぞれのコマンドが終了するのを順番に待ちます。 返却ステータスは、最後に実行したコマンドの終了ステータスになります。

AND リストと OR リストは、それぞれ制御演算子 && と || で区切られたパイプラインの並びです。 AND リストと OR リストは左結合で実行されます。 AND リストは

command1 && command2

という形式であり、 command1 が終了ステータス 0 を返した場合に限り command2 が実行されます。

OR リストは

command1 || command2


という形式であり、 command1 が 0 以外の終了ステータスを返した場合に限り command2 が実行されます。 AND リストと OR リストの返却ステータスは、 リスト中で最後に実行されたコマンドの終了ステータスです。

# 複合コマンド (Compound Commands)
複合コマンド (compound command) を以下に示します:

* (list)
list はサブシェル内で実行されます (後述の コマンド実行環境 の項を参照)。 シェルの環境に影響を与えるような変数の代入や組み込みコマンドは、 コマンドの終了後に影響を残しません。 返却ステータスは list の終了ステータスです。

# クォート
クォート (quoting) を使うと、 特定の文字や単語が持つシェルに対する特別な意味をなくせます。 クォートを用いると、特殊文字の特殊な扱いを無効にしたり、 予約語が予約語として識別されることを防いだり、 パラメータの展開を防いだりできます。
前述の 定義 で挙げたメタ文字 (metacharacters) にはそれぞれ特殊な意味があるので、 その文字自身を表すためにはクォートしなければなりません。

シングルクォートで文字を囲むと、 クォート内部のそれぞれの文字は文字としての値を保持します。 シングルクォートの間にシングルクォートを置くことはできません。 これはバックスラッシュを前に付けても同じです。

ダブルクォートで文字を囲むとクォート内部の全ての文字は文字としての値を 保持しますが、 $, `, \ は例外となります。
$ と ` はダブルクォートの内部でも特殊な意味を失いません。 バックスラッシュの場合は、次の文字が $, `, ", \, <newline> のいずれかである場合に限り特殊な意味を失いません。 前にバックスラッシュを付ければ、 ダブルクォート文字をダブルクォートによるクォートの内部で クォートできます。

# パラメータ（要件外）
パラメータ (parameter) は値を保持するためのものです。パラメータは 名前、 数字、後述の 特殊なパラメータ で挙げる特殊文字のいずれかで表現されます。シェルでの用法においては、 変数(variable) とは 名前 で表現されたパラメータです。 変数は値と 0 個以上の属性を持ちます。
パラメータに値が代入されていれば、 そのパラメータは設定 (set) されていると言われます。 空文字列も有効な値です。一度値を設定すると、組み込みコマンドの unset を使わなければ削除 (unset) できません (後述の シェルの組み込みコマンド を参照)。

変数 には、以下の構文で代入できます:

name=[value]

value が与えられなかった場合、変数には空文字列が代入されます。全ての value に対して、チルダ展開、パラメータと変数の展開、コマンド置換、 算術式展開、クォート除去が行われます (後述の 展開 を参照)。



# 特殊パラメータ
シェルはいくつかのパラメータを特別扱いします。 このようなパラメータは参照されるだけであり、 値を代入することは許されません。

?
最後に実行されたフォアグラウンドのパイプラインの 終了ステータスに展開されます。

# シェル変数から環境変数への継承（ほぼ要件外）

bashではシェル変数として扱われているもののうち、使うものは環境変数に継承されます。
各変数の意味は以下に示します:

* **BASH**
現在実行している bash を起動したときに使われた、完全なファイル名に展開されます。
* **BASHPID**
現在の bash のプロセス ID に展開されます。 bash を再初期化しないサブシェルのような、いくつかの環境においては、 $$ と値が異なります。

* **HISTCMD**
現在のコマンドの履歴番号 (履歴リストにおけるインデックス) です。 HISTCMD を unset すると、この変数の特殊な性質はなくなります。後で再び set しても元には戻りません。
* **OLDPWD**
cd コマンドで設定された、1 つ前の作業ディレクトリ。
* **PWD**
cd コマンドで設定された現在の作業ディレクトリ。


* **BASH_ENV**
bash がシェルスクリプトを実行するときにこの値が設定されている場合、 この値は (~/.bashrc のように) シェルを初期化するコマンドが書かれているファイル名と解釈されます。 BASH_ENV の値をファイル名として処理する前には、パラメータ展開、コマンド置換、 算術的展開が行われます。 この結果のファイルを検索する際には PATH は使用されません。
* **CDPATH**
cd コマンドの検索パスです。これは、 cd コマンドで指定した対象ディレクトリを探すディレクトリを コロンで区切って並べたリストです。 例えば、 ".:~:/usr" といった値になります。
* **GLOBIGNORE**
パス名展開で無視するファイル名の集合を定義するパターンを コロンで区切って並べたリストです。 パス名展開パターンにマッチするファイル名が GLOBIGNORE 内のパターンのどれかにもマッチする場合、 マッチしたもののリストから削除されます。
* **HISTCONTROL**
履歴リストに入れるコマンドを制御する値をコロンで区切って並べたリストです。 ignorespace の値が設定されていると、 空白 文字で始まる行は履歴リストに入りません。 ignoredups の値が設定されていると、 履歴の最後の行にマッチする行は履歴リストに入りません。 ignoreboth を指定すると ignorespace と ignoredups の両方が指定されます。 erasedups の値が設定されていると、行が保存される前に、 現在の行に一致する過去の行が履歴リストから削除されます。 上記以外の値を設定しても無視されます。 HISTCONTROL が設定されていない場合や、不正な値が設定されている場合には、 シェルのパーザが読み込んだ全ての行は HISTIGNORE の値が示す条件の下で履歴リストに保存されます。 複数行にまたがる複合コマンドの場合は 2 番目以降の行が調べられることはありません。よって、これらは HISTCONTROL の値に関わらず履歴に追加されます。
* **HISTFILE**
コマンド履歴が保存されるファイルの名前 (後述の 履歴 を参照)。デフォルト値は ~/.bash_history です。 設定されていない場合、 対話シェルが終了するときに履歴の保存が行われません。
* **HISTFILESIZE**
履歴ファイルに保持する履歴の最大数です。この変数に値が代入された場合、 その行数を越えないように、必要に応じて古いエントリを削除して履歴ファイルを 切り詰めます。 デフォルト値は 500 です。対話シェルが終了するときにも、 履歴ファイルのサイズはファイル書き込みの後にこのサイズに切り詰められます。
* **HISTIGNORE**
どのコマンド行を履歴リストに保存するかを決めるために使うパターンを コロンで区切って並べたリストです。 それぞれのパターンは行の先頭から比較され、 行全体と完全に一致しなければなりません (`*' が暗黙的に追加されるこ とはありません)。行に対する各パターンの評価は HISTCONTROL で指定したチェックが行われた後で実行されます。 通常のシェルのパターンマッチング文字以外に、 `&' が履歴の前の行にマッチします。 バックスラッシュを使って `&' をエスケープできます。 マッチングを試みる前にバックスラッシュは取り除かれます。 複数行にまたがる複合コマンドの場合、2 番目以降の行は調べられません。 よって、これらは HISTIGNORE の値に関わらず履歴に追加されます。
* **HISTSIZE**
コマンド履歴に記憶するコマンドの数 (後述の HISTORY を参照)。 デフォルトは 500 です。
* **HOME**
現在のユーザのホームディレクトリです。 組み込みコマンド cd のデフォルトの引き数になります。 この変数の値は、チルダ展開を実行するときにも使われます。
* **HOSTFILE**
/etc/hosts と同じフォーマットであり、 シェルがホスト名を補完する必要があるときに読み込むファイルの名前を示します。 シェルの実行中でも補完するホスト名のリストを変更できます。 この変数が変更された次の機会にホスト名の補完を試みるとき、 bash は新しいファイルの内容を既存のデータベースに追加します。 HOSTFILE が設定されているがその値が空文字列の場合や、 読み込めるファイルの名前ではない場合には、 bash は補完可能なホスト名のリストを取得するために /etc/hosts を使用します。 HOSTFILE が unset された場合は、ホスト名のリストはクリアされます。
* **IFS**
内部フィールド区切り文字 (Internal Field Separator) です。展開を行った後に単語を分割する場合や、組み込みコマンドの read を使ったときに行を単語に分割する場合に使われます。 デフォルト値は ``<空白><タブ><改行>'' です。
* **IGNOREEOF**
単独で入力された EOF 文字を受け取ったときの対話シェルの動作を制御します。 この変数が設定されていれば、指定されている値の数だけの EOF 文字を連続して行頭の文字として入力しなければ bash は終了しません。この変数に数値以外の値が設定されている場合や、 空の値が設定されている場合には、デフォルト値として 10 が使われます。 この変数が存在しなければ、 EOF 文字はシェルへの入力の終わりを示します。
* **PATH**
コマンドの検索パスです。 シェルがコマンドを検索するディレクトリをコロンで区切って並べたリストです (後述の コマンドの実行 を参照)。 PATH 中の長さ 0 の (空の) ディレクトリ名は、カレントディレクトリを示します。 空のディレクトリ名は、2 つのコロンを並べるか、 先頭や末尾のコロンで表します。 デフォルトのパスはシステム依存で、 bash をインストールしたシステム管理者が設定します。 一般的な値は ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin'' です。
* **PS1**
このパラメータの値は展開されてプライマリのプロンプト文字列として使われます。 (後述の プロンプト を参照)、 デフォルト値は ``\s-\v\$ '' です。
* **PS2**
このパラメータの値は PS1 と同じように展開され、セカンダリのプロンプト文字列として使われます。 デフォルト値は ``> '' です。
* **SHELL**
この環境変数にシェルのフルパス名が保存されています。 シェルを起動したときに設定されていない場合は、 bash が現在のユーザのログインシェルのフルパス名を代入します。

* **TMPDIR**
設定すると、値を bash がシェル用にテンポラリファイルを作る ディレクトリ名として使います。

# 展開（ほぼ要件外）
展開はコマンドラインが単語へ分割された後に (コマンドライン上で) 行われます。行われる展開は 5 種類あります:
* チルダ展開 (tilde expansion),
* パラメータと変数の展開 (parameter and variable expansion),
* コマンド置換 (command substitution),
* 単語の分割 (word splitting),
* パス名展開 (pathname expansion)。

展開の順序は次のようになります:

 1. チルダ展開
 1. パラメータ・ 変数・算術式展開
 1. コマンド置換 (左から右へ)
 1. 単語分割
 1. パス名展開（一部要件内）

これらに加えて プロセス置換 (process substitution) をサポートできるシステムもあります。


## チルダ展開 (要件外)
クォートされていないチルダ (`~') で単語が始まった場合、 クォートされていないスラッシュよりも前にある文字全て (クォートされていないスラッシュが無ければ全ての文字) はチルダプレフィックス (tilde-prefix) と解釈されます。 クォートされている文字がチルダプレフィックス中に無ければ、 チルダプレフィックス中のチルダ以降の文字は、 ログイン名 (login name) になるかもしれない文字列として扱われます。 このログイン名が空文字列ならば、チルダはシェルパラメータ HOME の値に置き換えられます。 HOME が設定されていない場合は、代わりにシェルを実行しているユーザの ホームディレクトリに置き換えられます。 ログイン名が空でなければ、 チルダプレフィックスは指定されたログイン名に対応する ホームディレクトリに置き換えられます。

チルダプレフィックスが `~+' ならば、チルダプレフィックスはシェル変数 PWD の値に置き換えられます。 チルダプレフィックスが `~-' ならば、シェル変数 OLDPWD の値に置き換えられます (値が設定されていれば)。 チルダプレフィックス中のチルダより後の文字が数値 N であれば (数値の前に `+' や `-' を置くこともできます)、 チルダプレフィックスはディレクトリスタック内の対応する要素に置換されます。 置換される要素は、チルダプレフィックスを引き数として組み込みコマンド dirs を実行したときに表示されるものです。 チルダプレフィックスにおけるチルダ以降の文字が、 先行する `+' や `-' のない数値である場合は、`+' であるとみなされます。

ログイン名が有効でない場合や、チルダ展開が失敗した場合には、 単語は置き換えられません。

全ての変数代入において、 : や = の直後にクォートされていないチルダプレフィックスがないかチェックが行われます。 もし見つかった場合にはこれらもチルダ展開されます。 したがって、 PATH, MAILPATH, CDPATH への代入にチルダを含むファイル名を使えば、 シェルは展開された値を代入します。

## パラメータの展開
>  Handle environment variables ($ followed by a sequence of characters) which
 **should expand to their values**

`$' 文字があると、パラメータ展開、コマンド置換、 算術式展開が行われます。展開されるパラメータ名やシンボルは、 ブレースで括ることもできます。 ブレースは省略可能ですが、 変数の直後に変数名の一部と解釈できる文字が置かれた場合に、 その文字と共に変数が展開されてしまうのを防ぐために用意されています。

ブレースを使った場合、対になるのは最初に表れる `}' です。 ただしバックスラッシュでエスケープされているものや クォートされている文字列中のものは含まれませんし、ブレースの内側にある 算術式展開やコマンド置換、パラメータ展開に入っているものも含まれません。


${parameter}
parameter の値に置換されます。ブレースが必要になるのは、 parameter が 2 桁以上の数字を持つ位置パラメータの場合や、 parameter の直後の文字を名前の一部として解釈させたくない場合です。
parameter の最初の文字が感嘆符ならば、変数間接展開が行われます。 bash は残りの parameter からなる変数の値を変数の名前と見なします。 そしてそこで得られた名前の変数を展開した値を、置換処理の続きで使います。 これが 間接展開 です。 ただし ${!prefix*} や ${!name[@]} の展開は例外です。 これは以下で説明します。 間接展開を表すには、感嘆符は左ブレースの直後に続ける必要があります。

以下に示すそれぞれの場合、word に対してチルダ展開、 パラメータ展開、コマンド置換、算術式展開が行われます。

部分文字列展開以外の場合、以下の形式で、 bash はパラメータが設定されているか、空ではないかを調べます。 コロンを省略した場合には設定されているかどうかのみを調べます。


${parameter:-word}
デフォルトの値を使います。 parameter が設定されていないか空文字列であれば、 word を展開したものに置換されます。そうでなければ、 parameter の値に置換されます。
${parameter:=word}
デフォルトの値を代入します。 parameter が設定されていないか空文字列であれば、 word を展開したものが parameter に代入されます。それから parameter の値への置換が行われます。 位置パラメータや特殊パラメータへの代入をこのように行うことはできません。
${parameter:?word}
空文字列または設定されていない場合にエラーを表示します。 parameter が空文字列または設定されていない場合、word を展開したもの (word がなければ パラメータが空文字列または設定されていないことを示すメッセージ) が標準エラー出力に出力されます。シェルが対話的でなければ、 シェルは終了します。パラメータに空文字列以外が設定されていれば、 parameter の値への置換が行われます。
${parameter:+word}
別の値を使用します。 parameter が空文字列または設定されていなければ、空文字列に置換されます。 そうでなければ word を展開したものに置換されます。
${parameter:offset}
${parameter:offset:length}
部分文字列展開。 parameter を展開したものから最大 length 文字を取り出します。 先頭の文字は offset で指定します。length を省略すると、 offset で指定した文字を先頭にして、 parameter の残り全部が含まれる部分文字列に展開します。 length と offset は算術式です (後述の 算術式評価 を参照)。 offset を評価すると 0 未満の数になる場合、この値は parameter の値の末尾からのオフセットとして使われます。 length を評価すると 0 未満の数になる場合、 parameter が @ ではなく、配列でも連想配列でもなければ、 この値は文字数ではなく parameter の値の末尾からのオフセットとして使われ、 展開結果は 2 つのオフセットの間の部分文字列となります。 parameter が @ ならば、結果は offset から始まる length 個の位置パラメータになります。 parameter が @ または * のインデックスが付いている配列名ならば、 結果は配列の ${parameter[offset]} を先頭とする要素 length 個となります。 負の offset は、指定された配列の最大のインデックス + 1 からの相対値と解釈されます。 連想配列に部分文字列展開した場合の結果は決められていません。 負のオフセットを指定するときには、:- 式と混同されないよう、 1 つ以上の空白でコロンと離す必要があることに注意してください。 位置パラメータを使う場合以外は、 部分文字列のインデックスは 0 から始まります。位置パラメータの場合には、 インデックスは 1 から始まります。 位置パラメータが使われて offset が 0 の場合、 $0 の値が先頭に置かれます。
${!prefix*}
${!prefix@}
前方一致する変数名。 prefix で始まる全ての変数の名前に展開して、 IFS 特殊変数の最初の文字によって区切ります。 ダブルクォートの中で @ が使われた場合、それぞれの変数の名前は 別々の単語に展開されます。
${!name[@]}
${!name[*]}
配列のキーのリスト。 name が配列変数であれば、配列 name の インデックス (キー) のリストに展開されます。 name が配列でない場合は、name が設定されていれば 0 に、 そうでなければ空に展開されます。 ダブルクォートの中で @ が使われた場合、それぞれのキーは 別々の単語に展開されます。
${#parameter}
パラメータの長さ。 parameter の値に含まれる文字数に置換されます。 parameter が * または @ ならば、位置パラメータの数に置換されます。 parameter が * または @ が添字になっている配列名ならば、配列中の要素数に置換されます。
${parameter#word}
${parameter##word}
パターンに前方一致した部分を取り除く。 word が展開され、パス名展開の場合と同じようなパターンを作ります。 このパターンが parameter の値の先頭部分とマッチする場合、展開して得られる値は parameter を展開した値から最短一致パターン (``#''の場合) または最長一致パターン (``##'' の場合) を取り除いたものになります。 parameter が @ または * である場合、 パターンを削除する操作は全ての位置パラメータに順番に適用され、 展開結果はリストとして得られます。 parameter が @ または * が添字になっている配列変数である場合、 パターンを削除する操作は配列の全ての要素に順番に適用され、 展開結果はリストとして得られます。
${parameter%word}

```txt
${parameter%%word}
パターンに後方一致した部分を取り除く。 word が展開され、パス名展開の場合と同じようなパターンを作ります。 このパターンが parameter を展開した値の末尾の部分とマッチする場合、展開結果は parameter を展開した値から最短一致パターン (``%'' の場合) または最長一致パターン (``%%'' の場合) を取り除いたものになります。 parameter が @ または * である場合、 パターンを削除する操作は全ての位置パラメータに順番に適用され、 展開結果はリストとして得られます。 parameter が @ または * が添字になっている配列変数である場合、 パターンを削除する操作は配列の全ての要素に順番に適用され、 展開結果はリストとして得られます。
```

```txt
${parameter/pattern/string}
パターンの置換。 pattern が展開され、 パス名展開の場合と同じようなパターンを作ります。 parameter の展開が行われ、 その値のうち pattern に最長一致する部分が string に置換されます。 pattern が / で始まる場合には、pattern に マッチした部分は全て string に置換されます。 そうでない場合には、最初にマッチした部分だけが置換されます。 pattern が # で始まる場合には、パターンは parameter を展開した値の先頭にマッチしなければなりません。 pattern が % で始まる場合には、パターンは parameter を展開した値の末尾にマッチしなければなりません。 string が空の場合には pattern にマッチした部分は削除されます。 またこの場合には、pattern の後に続く / は省略可能です。 parameter が @ または * である場合、置換操作は全ての位置パラメータに順番に適用され、 展開結果はリストとして得られます。 parameter が @ または * が添字になっている配列変数である場合、 置換操作は配列の全ての要素に順番に適用され、 展開結果はリストとして得られます。
```

```txt
${parameter^pattern}
${parameter^^pattern}
${parameter,pattern}
${parameter,,pattern}
```
大文字小文字の変換。 parameter に含まれるアルファベットの大文字小文字を変換します。 pattern が展開され、 パス名展開の場合と同じようなパターンを作ります。 ^ 演算子は pattern にマッチした小文字を大文字に変換します。 , 演算子は pattern にマッチした大文字を小文字に変換します。 ^^ 演算子と ,, 演算子は、マッチした全ての文字を変換します。 ^ 演算子と , 演算子の場合は、マッチした最初の文字だけ変換します。 pattern を省略した場合、? を指定したものとして扱われ、 全ての文字にマッチします。 parameter が @ または * である場合、大文字小文字の変換は全ての位置パラメータに順番に適用され、 展開結果はリストとして得られます。 parameter が添字に @ または * の付いた配列変数の場合は、配列の要素のそれぞれに大文字小文字の変換が適用され、 結果はリストに展開されます。
コマンド置換
コマンド置換 (command substitution) を用いると、 コマンド名をコマンドの出力で置き換えられます。 コマンド置換には以下の 2 つの形式があります:

$(command)

または
`command`
bash は command を実行し、 command の標準出力でコマンド置換の部分を置き換えます。 この際、末尾の改行文字は削除されます。 文字列の途中にある改行文字は削除されませんが、 単語分割の際に削除されることがあります。 コマンド置換 $(cat file) は、同じ意味を持ち、 しかも高速な $(< file) に置き換え可能です。

バッククォートを使う古い形式の置換を用いたとき、 バックスラッシュは文字通りの意味を保ちますが、 $, `, \ の前にある場合は例外となります。 コマンド置換は、バックスラッシュが前置されていない バッククォートまでの部分です。 $(command) という形式を用いたときは、 括弧の間にある全ての文字がコマンドとなります。 特別扱いされる文字はありません。

コマンド置換は入れ子にできます。 バッククォート形式のときに入れ子を行うには、 内側のバッククォートをバックスラッシュでエスケープします。

置換がダブルクォート内部にある場合には、 置換の結果に対する単語分割とパス名展開は行われません。

## 単語の分割（要件外（要件に明記はされていない））
パラメータ展開、コマンド置換、算術式展開が行われたのが、ダブル クォートの内側ではない場合、シェルは展開の結果をスキャンして、 単語分割 を行います。

シェルは IFS のそれぞれの文字を区切り文字として扱い、 ほかの展開の結果をこれらの文字によって単語に分割します。 IFS が設定されていないか、その値がデフォルト値の <スペース><タブ><改行> と全く同じならば、前段の展開の結果の先頭や末尾の <スペース>, <タブ>, <改行> の並びは無視され、 先頭と末尾以外の IFS 文字の並びで単語が区切られます。 IFS の値がデフォルト以外のときに、 スペース や タブ という空白文字の並びが単語の先頭と末尾で無視されるのは、 その空白文字が IFS の値に含まれるとき ( IFS の空白文字の一つであるとき) だけです。 IFS に含まれ、 IFS 空白文字ではない文字は全て、隣接する任意の IFS 空白文字と一緒になってフィールドの区切りとなります。 IFS 空白文字の列も区切り文字として扱われます。 IFS の値が空文字列であれば、単語分割は全く行われません。

明示的に指定した空の引き数 ("" または '') は削除されずに残ります。 クォートされていない暗黙的な空の引き数が、 値を持たないパラメータを展開した結果として得られますが、 これらは削除されます。 値を持たないパラメータがダブルクォート内部で展開されると、 空である引き数となり、消されずに残ります。

展開が行われなければ単語分割も行われない点に注意してください。

## パス名展開（＊に関する内容だけ要件に明記されている）
-f オプションが指定されていなければ、単語分割を行った後に bash はそれぞれの単語が *, ?, [ を含んでいるかどうか調べます。 これらの文字のいずれかが見つかると、その単語は パターン とみなされ、 パターンにマッチするファイル名を アルファベット順にソートしたリストに置換されます。 マッチするファイル名が見つからず、かつシェルのオプション nullglob が無効ならば、その単語は変更されずにそのまま残ります。 nullglob オプションが設定されていて、かつマッチするファイル名が見つからなければ、 その単語は削除されます。 failglob オプションが設定されていて、かつマッチするファイル名が見つからなければ、 エラーメッセージが表示されコマンドは実行されません。 シェルのオプション nocaseglob が有効ならば、マッチングにおいてアルファベットの大文字と小文字は区別さ れません。 パターンをパス名展開に使うとき、名前の先頭やスラッシュの直後の ``.'' は明示的にマッチさせなければなりません。ただしシェルのオプション dotglob が設定されている場合は例外です。 パス名のマッチングを行うとき、 スラッシュ文字は必ず明示的にマッチさせなければなりません。 これ以外の場合には、 ``.'' が特別扱いされることはありません。 シェルのオプション nocaseglob, nullglob, failglob, dotglob の詳しい説明については、後述の シェルの組み込みコマンド に書かれている shopt の説明を参照してください。

シェル変数 GLOBIGNORE を使って、 パターン にマッチするファイル名の集合を制限できます。 GLOBIGNORE が設定されていれば、マッチするファイル名のうち GLOBIGNORE 中のパターンにもマッチしたものは、 マッチしたもののリストから取り除かれます。 ファイル名 ``.'' と ``..'' は GLOBIGNORE に空でない値が設定されていても必ず無視されます。しかし、 GLOBIGNORE に空でない値を設定するとシェルオプションの dotglob が有効になるので、 ``.'' で始まるほかのファイル名は全てマッチします。 ``.'' で始めるファイル名を無視する古い動作をさせるには、 ``.*'' を GLOBIGNORE のパターンに含めてください。 GLOBIGNORE を unset すると、 dotglob オプションは無効になります。

### パターンマッチング

パターンに含まれる文字のうち、以下の特殊パターン文字以外の文字は、 自分自身にマッチします。NUL 文字がパターン中に現われてはいけません。 バックスラッシュは直後の文字をエスケープします。 このバックスラッシュは、マッチングでは無視されます 特殊パターン文字をその文字そのものにマッチさせるためには、 クォートしなければなりません。

特殊パターン文字は以下の意味を持っています:

* *
空文字列を含む、任意の文字列にマッチします。 シェルオプション globstar が有効で、 * がパス名展開に用いられる場面では、 連続する 2 つの * だけのパターンが使われると、 その階層以下のディレクトリとそのサブディレクトリ、 そこにある全てのファイルにマッチします。 2 つ連続した * の後に / が続く場合には、 ディレクトリとそのサブディレクトリのみにマッチします。
* ?
任意の 1 文字にマッチします。
* [...]
括られた文字のうち任意の 1 文字にマッチします。 2 つの文字の間にハイフンを入れたものは、 範囲表現 (range expression) を表します。 ソート順で両端を含む 2 つの文字の間にある任意の 1 文字と マッチします。 ソートには現在のロケールの照合順序 (collating sequence) と文字セットが用いられます。 [ の次の文字が ! または ^ ならば、括られた文字に含まれない任意の 1 文字にマッチします。 範囲表現における文字のソート順は、 現在のロケール (およびシェル変数 LC_COLLATE が指定されていればその値) によって決定されます。 - は、文字集合の最初または最後の文字として含めると マッチングの対象にできます。 ] は、文字集合の最初の文字として含めるとマッチングの対象にできます。
[ と ] の間では、文字クラス (character classes) を指定できます。 指定には [:class:] という記法を使います。ここで class は POSIX 標準で定義されている以下のクラスのいずれかです:


alnum alpha ascii blank cntrl digit graph lower print punct space upper word xdigit
文字クラスは、そのクラスの属する任意の文字にマッチします。 文字クラス word は、文字、数字、_ にマッチします。
[ と ] の間では、等値クラス (equivalence class) を指定できます。 指定には [=c=] という記法を使います。 これは現在のロケールにおける定義において c と同じ 照合重み (collation weight) を持つ全ての文字にマッチします。

[ と ] の間では、[.symbol.] という記述は照合シンボル symbol にマッチします。

組み込みコマンドの shopt を使ってシェルのオプション extglob が有効にされていると、 拡張パターンマッチング演算子がいくつか認識されるようになります。 以下の説明では、pattern-list は | で区切られた 1 つ以上のパターンのリストであるものとします。 以下のサブパターンを 1 つあるいは複数使うことにより、 複合パターンを作れます。


* ?(pattern-list)
与えられたパターンが 0 回または 1 回現われるとマッチします。
* *(pattern-list)
与えられたパターンが 0 回以上現われるとマッチします。
* +(pattern-list)
与えられたパターンが 1 回以上現われるとマッチします。
* @(pattern-list)
与えられたパターンに 1 回だけマッチします。
* !(pattern-list)
与えられたパターンのどれでもないものにマッチします。

# クォートの削除
先に処理される展開の後、クォートされていない \, ', " のうち、先の展開の結果でないものは全て削除されます。

# リダイレクト（一部のみ要件に明記されている）
シェルが解釈する特別な記法を用いると、コマンドの実行前に入出力を リダイレクト できます。またリダイレクトを使うと、 現在のシェル実行環境に対してファイルをオープンしたり クローズしたりできます。以下に示すリダイレクト演算子は、 単純なコマンド の前や途中に置くことができ、また コマンド の後に置けます。 リダイレクトは左から右へと、現われた順に処理されます。
ファイル・ディスクリプター番号で始まるリダイレクトでは、 代わりに {varname} という形式の単語で始めることもできます。 この場合、>&- と <&- 以外のリダイレクト演算子では、 シェルは 10 より大きいファイル・ディスクリプターを割り当て、 varname に代入します。 {varname} で始まる >&- や <&- の場合には、varname の値は クローズするファイル・ディスクリプターを示します。

以下の説明においては、ファイル・ディスクリプター番号が省略され、 かつリダイレクト演算子の最初の文字が < ならば、リダイレクトは標準入力 (ファイル・ディスクリプター 0) を参照します。 リダイレクト演算子の最初の文字が > ならば、リダイレクトは標準出力 (ファイル・ディスクリプター 1) を参照します。

以下の説明では、リダイレクト演算子の次の単語に対しては、 特に説明しない限り、 ブレース展開・チルダ展開・パラメータ展開・コマンド置換・ 算術式展開・クォート削除・パス名展開・単語分割が行われます。 その単語が複数の単語に展開された場合はエラーになります。

リダイレクトの順番には意味がある点に注意してください。 例えば、次のコマンド

ls > dirlist 2>&1

は標準出力と標準エラー出力を両方ともファイル dirlist に書き込みますが、次のコマンド

ls 2>&1 > dirlist

では標準出力だけがファイル dirlist に書き込まれます。なぜなら後者の場合には、標準エラー出力は dirlist にリダイレクトされる前の標準出力の複製となるからです。

bash は、 以下の表にあるようなファイル名がリダイレクトに使用されると、 それらを特別に扱います。


* /dev/fd/fd
fd が有効な整数ならばファイル・ディスクリプター fd が複製されます。
* /dev/stdin
ファイル・ディスクリプター 0 が複製されます。
* /dev/stdout
ファイル・ディスクリプター 1 が複製されます。
* /dev/stderr
ファイル・ディスクリプター 2 が複製されます。
* /dev/tcp/host/port
host が有効なホスト名またはインターネットアドレスで port が整数のポート番号ならば、 bash は対応するソケットに対して TCP 接続のオープンを試みます。
* /dev/udp/host/port
host が有効なホスト名またはインターネットアドレスで port が整数のポート番号ならば、 bash は対応するソケットに対して UDP 接続のオープンを試みます。
ファイルのオープンや作成に失敗すると、リダイレクトも失敗します。

9 より大きいファイル・ディスクリプターを使ったリダイレクトには注意が 必要です。シェルが内部的に使うファイル・ディスクリプターと競合する場合が あるからです。

## 入力のリダイレクト（一部要件内）
入力をリダイレクトすると、 word を展開した結果の名前を持つファイルがオープンされ、 ファイル・ディスクリプター n で読み込めるようになります。 n が指定されていなければ、読み込みは標準入力 (ファイル・ディスクリプター 0) で行われます。

入力のリダイレクトは、一般的には以下の形式です:

[n]<word

## 出力のリダイレクト（一部要件内）
出力をリダイレクトすると、 word の展開した結果の名前を持つファイルがオープンされ、 ファイル・ディスクリプター n で書き込めるようになります。 n が指定されていなければ、書き込みは標準出力 (ファイル・ディスクリプター 1) に行われます。 ファイルが存在しなかった場合は作成されます。 ファイルが存在した場合はサイズ 0 に切り詰められます。

出力のリダイレクトは、一般的には以下の形式です:

[n]>word

リダイレクト演算子が > であり、かつ 組み込みコマンド set で noclobber オプションが有効になっている場合、 word の展開で得たファイルが存在し、 かつそれが通常ファイルならば、リダイレクトは失敗します。 リダイレクト演算子が >| の場合、もしくは リダイレクト演算子が > で組み込みコマンド set で noclobber オプションが有効になっていない場合、 word という名前のファイルが存在していてもリダイレクトが試みられます。

## リダイレクトによる追加出力（一部要件内）
この形式を使って出力のリダイレクトを行うと、 word を展開した結果の名前を持つファイルがオープンされ、 ファイル・ディスクリプター n に対する出力がこのファイルに追加されるようになります。 n を指定しなければ、標準出力 (ファイル・ディスクリプター 1) で追加されます。 ファイルが存在しなければ、新しく作られます。

追加出力は一般的には以下の形式です:

[n]>>word


## 標準出力と標準エラー出力のリダイレクト（要件外）
この構造を使うと、 標準出力 (ファイル・ディスクリプター 1) と標準エラー出力 (ファイル・ディスクリプター 2) の両方を、 word を展開した結果の名前を持つファイルにリダイレクトできます。

標準出力と標準エラー出力に対する形式は 2 つあります:

&>word

と
>&word
両者のうち望ましいのは前者の方です。 上記は以下と同じ意味です:

>word 2>&1


## 標準出力と標準エラー出力の追加出力（要件外）
この構造を使うと、 標準出力 (ファイル・ディスクリプター 1) と標準エラー出力 (ファイル・ディスクリプター 2) の両方を、 word を展開した結果の名前を持つファイルに追加できます。

標準出力と標準エラー出力の追加出力は以下の形式です:

&>>word

これは次のものと同じ意味です:

>>word 2>&1

## ヒアドキュメント(Here Documents)（一部要件内）
この形式のリダイレクトを用いると、 シェルは現在のソースから入力を読み込みます。 この読み込みは word を単独で含む行 (末尾にブランク文字があってはいけません) が現われるまで続きます。 その行までに読み込んだ行は、 コマンドの標準入力として扱われます。

ヒアドキュメントの形式を以下に示します:


<<[-]word
        here-document
delimiter
word に対するパラメータ展開・コマンド置換・算術式展開・ パス名展開は全く行われません。 word が一部でもクォートされている場合は、 delimiter は word のクォートをほどいた結果 (クォート文字を削除した結果) となり、 ヒアドキュメントに含まれる行では展開が行われなくなります。 word がクォートされていなければ、 ヒアドキュメント中の全ての行に対して パラメータ展開・コマンド置換・算術式展開が行われます。 word がクォートされていない場合には、 \<newline> という文字列は無視され、 \, $, ` といった文字は \ を用いてクォートしなければなりません。

リダイレクト演算子が <<- ならば、行頭にあるタブ文字は全て入力行および delimiter を含む行から取り除かれます。 これにより、シェルスクリプト中のヒアドキュメントを 自然な形でインデントさせることができます。

## ヒアストリング(Here Strings)（要件外）
ヒアドキュメントの変形で、以下の形式です:

<<<word
word は展開されてコマンドの標準入力に与えられます。

## ファイル・ディスクリプターの複製（要件外）
リダイレクト演算子

[n]<&word

を使うと入力ファイル・ディスクリプターを複製できます。 word が 1 桁以上の数値に展開された場合、 n で示されるファイル・ディスクリプターが生成され、 word で指定された数値のファイル・ディスクリプターのコピーとなります。 word に含まれる数値が入力用にオープンされたファイル・ディスクリプターを 指していない場合、リダイレクト・エラーが起きます。 word を評価した結果が - となった場合、ファイル・ディスクリプター n はクローズされます。 n が指定されていない場合、標準入力 (ファイル・ディスクリプター 0) が使われます。

同様に、演算子

[n]>&word

を使って出力ファイル・ディスクリプターを複製できます。 n が指定されていない場合は、標準出力 (ファイル・ディスクリプター 1) が使われます。 word に含まれる数値が、出力用にオープンされた ファイル・ディスクリプターを指していない場合、 リダイレクト・エラーが起きます。特別な場合ですが、 n が省略され、かつ word が 1 桁以上の数字には展開されなかった場合、 前に説明したように標準出力と標準エラー出力がリダイレクトされます。

## ファイル・ディスクリプターの変更（要件外）
リダイレクト演算子

[n]<&digit-

を使うと、ファイル・ディスクリプターの digit を n に変更します。 n が指定されていない場合は、標準入力 (ファイル・ディスクリプター 0) が使われます。 digit は n に複製された後にクローズされます。

同様に、演算子

[n]>&digit-

を使うと、ファイル・ディスクリプターの digit を n に変更します。 n が指定されていない場合は、標準出力 (ファイル・ディスクリプター 1) が使われます。

## 読み書きのためのファイル・ディスクリプターのオープン（要件外）
リダイレクト演算子

[n]<>word

を使うと、 word を展開した結果の名前を持つファイルがファイル・ディスクリプター n での読み書きのためにオープンされます。 n が指定されていなければ、 ファイル・ディスクリプター 0 で読み書きが行われます。 ファイルが存在しなければ、新しく生成されます。

# 単純なコマンドの展開（要件には明記無し）
単純なコマンドを実行すると、シェルは以下に示す展開、代入、 リダイレクションを左から右の順で実行します。
1. パーザが変数代入 (コマンド名の前にあるもの) またはリダイレクションと判断した単語は、 保存されて後で処理されます。
2. 変数代入でもリダイレクションでもない単語が展開されます。 もし展開の後に残っている単語があれば、 その最初の単語がコマンド名となり、残りが引き数となります。
3. リダイレクションが前述の リダイレクト で説明したように実行されます。
4. 変数代入の = の後にあるテキストに対して、チルダ展開、 パラメータ展開、コマンド置換、算術式展開、クォート削除が行われます。 この処理は変数を代入する前に行われます。
コマンド名が残らなかった場合には、 変数を代入した結果が現在のシェル環境に効果を及ぼします。 それ以外の場合、変数は実行されるコマンドの環境に追加されるだけで、 現在のシェル環境には影響を与えません。 読み込み専用の変数に対して代入をしようとするとエラーが発生し、 そのコマンドは 0 でないステータスで終了します。

コマンド名が残らなかった場合、リダイレクションは行われますが、 現在のシェル環境は影響を受けません。 リダイレクションのエラーが起きると、 コマンドは 0 でないステータスで終了します。

展開の後にコマンド名が残っている場合、後述するように実行が進行します。 そうでない場合はコマンドは終了します。 展開のいずれかがコマンド置換である場合には、 コマンドの終了ステータスは 最後に実行されたコマンド置換の終了ステータスになります。 コマンド置換が行われなかった場合には、 コマンドはステータス 0 で終了します。

# コマンドの実行（要件には明記無し）
コマンドが単語に分割された後に、 単純なコマンドとそれに対する引き数リスト (引き数リストは省略可能) となった場合、以下の動作が行われます。
コマンド名にスラッシュが含まれない場合、 シェルはコマンドの位置を特定しようとします。 その名前のシェル関数が存在すれば、前に 関数 で説明したようにその関数が呼び出されます。 名前が関数にマッチしない場合には、 シェルはシェルの組み込みコマンドのリストを探します。 マッチするものがあった場合、その組み込みコマンドが呼び出されます。

名前がシェル関数も組み込みコマンドでなく、 かつスラッシュを含まない場合には、 bash は PATH の各要素を検索し、その名前の実行ファイルを含むディレクトリを探します。 bash はハッシュ表を使って実行ファイルの完全なパス名を記憶します (後述の シェルの組み込みコマンド の hash の項を参照)。 PATH に含まれるディレクトリの完全な探索は、 そのコマンドがハッシュ表の中にない場合にのみ行われます。 探索に失敗すると、シェルは command_not_found_handle という名前のシェル関数の定義を探します。 存在する場合には、元のコマンドと元のコマンドの引き数を引き数として、 この関数を呼び出します。この関数の終了ステータスがシェルの 終了ステータスとなります。 この関数が定義されていない場合には、シェルはエラーメッセージを 表示して終了ステータス 127 を返します。

検索に成功したか、コマンド名に 1 つ以上のスラッシュが含まれる場合には、 シェルは指定されたプログラムを独立した実行環境で実行します。 引き数 0 には指定された名前が設定され、 コマンドに対する残りの引き数には (もしあれば) 指定された引き数が設定されます。

このファイルが実行可能フォーマットでないために実行が失敗し、 かつディレクトリでもない場合には、 このファイルは シェルスクリプト(shell script)であるとみなされます。 シェルスクリプトとは、シェルのコマンドが書かれているファイルのことです。 シェルスクリプトを実行するためにサブシェルが呼び出されます。 このサブシェルは自分自身を再初期化し、 シェルスクリプトを処理するために 新しいシェルが起動されたかのような結果になります。ただし、 親が記憶しているコマンドの位置 (後述の シェルの組み込みコマンド における hash の項を参照) は子にも引き継がれます。

プログラムが #! で始まるファイルである場合、 最初の行の残りの部分はこのプログラムのインタプリタを指定します。 シェルは指定されたインタプリタをオペレーティングシステム上で実行します。 オペレーティングシステムは、この実行可能フォーマットを直接処理しません。 インタプリタに対する引き数は、 プログラムの先頭の行のインタプリタ名の後の省略可能な引き数 1 つと、 その後のプログラム名、さらに (もしあれば) その後のコマンドへの引き数から構成されます。

# コマンド実行環境（要件には明記無し）
シェルは以下の要素からなる実行環境(execution environment)を持ちます:
* 起動時にそのシェルが継承したオープンされているファイル。 これは組み込みコマンド exec に与えられている リダイレクション機能で変更されます。
* ファイル作成モードのマスク。 シェルの親から継承します。
* シェルのパラメータ。環境内にある親シェルから継承します。

組み込みコマンドやシェル関数以外の単純なコマンドを実行するとき、 このコマンドは独立した実行環境内で呼び出されます。 この環境は以下の要素から成り立っています。 特に断らない限り、この値はシェルから引き継がれます。


* シェルのオープンしているファイルと、 コマンドに対するリダイレクションで指定した変更・追加を加えたもの。
* 現在の作業ディレクトリ
* ファイル作成モードのマスク
* エクスポートするシェル変数や関数と、 そのコマンドに対してエクスポートされた変数。 これらは環境で渡されます。
* シェルに捕捉されるトラップは、 そのシェルの親から継承された値に再設定されます。 そのシェルにより無視されるトラップは無視されます。
この独立の環境内で呼び出されたコマンドが、 (親である) シェルの実行環境に影響を及ぼすことはできません。

コマンド置換や括弧でグループ化されたコマンド、非同期コマンドは、 サブシェル環境内で呼び出されます。 このサブシェル環境はシェル環境を複製したものです。 パイプラインの一部として起動された組み込みコマンドは、 サブシェル環境で実行されます。サブシェル環境に対して行われた変更は、 元のシェル実行環境に影響を及ぼすことはできません。

# 環境
プログラムの起動時には、 環境 (environment) と呼ばれる文字列の配列が渡されます。 これは 変数名-値 のペアからなるリストで、 変数名=値 という形になります。

単純なコマンド や関数に対する環境は、一時的に修正できます。 これは、既に パラメータ の項で説明したように、パラメータ代入を前に置くことで行います。 このような代入が影響を与えるのは、 そのコマンドが参照する環境だけです。


bash が外部コマンドを起動したときには、変数 _ にはコマンドの完全なファイル名が設定され、 環境変数としてそのコマンドに渡されます。

# 終了ステータス（明記無し）
実行したコマンドの終了ステータスは、waitpid システムコールまたはそれに相当する関数が返した値です。 終了ステータスは 0 から 255 の値を取りますが、後述するように、 125 より大きい値は特別にシェルによって使われることがあります。 シェルの組み込みコマンドや複合コマンドの終了ステータスも、 同じ範囲に限定されています。 環境によっては、シェルは仕様で決められた失敗のモードを表す 特別の値を使います。

シェルは、終了コード 0 で終了したコマンドは正常終了したとみなします。 終了コード 0 は成功を示します。 0 以外の終了コードは失敗を示します。 あるコマンドが致命的なシグナル N で終了したときには、 bash は「128+N」の値を終了ステータスに使います。

コマンドが見つからなかった場合には、 そのコマンドを実行するために生成された子プロセスが ステータス 127 を返します。 コマンドが見つかったけれど実行できなかった場合には、 ステータスは 126 です。

展開やリダイレクションの際にエラーが発生し コマンドが失敗した場合には、 0 より大きい終了ステータスが返されます。

シェルの組み込みコマンドは、 成功した場合にはステータス 0 (真) を返し、 実行中にエラーが起こった場合には 0 でない値 (偽) を返します。 組み込みコマンドは全て、正しくない使い方であることを示すのに 終了ステータス 2 を返します。

bash 自身が返す終了ステータスは、文法エラーが起きた場合を除き、 実行した最後のコマンドの終了ステータスです。 文法エラーの場合には 0 でない値が終了ステータスとなります。 後述の組み込みコマンド exit も参照してください。

# シグナル（要件には明記無し）
bash が起動した外部コマンドは、 シェルが自分の親から継承した値をシグナルハンドラに設定します。 ジョブ制御が有効でないときには、非同期コマンドは、 継承したシグナルハンドラに加えて SIGINT と SIGQUIT も無視します。 コマンド置換の結果として実行されたコマンドは、 キーボードで生成されたジョブ制御シグナルを無視します。 無視されるシグナルは SIGTTIN, SIGTTOU, SIGTSTP です。

デフォルトでは、シェルは SIGHUP を受け取ると終了します。 終了する前には、シェルは実行中・停止中の全てのジョブに対して SIGHUP を再送信します。停止中のジョブには SIGCONT が送られ、このジョブが SIGHUP を受け取るようにします。 特定のジョブに対してシェルからシグナルが送られないようにするためには、 組み込みコマンド disown (後述の シェルの組み込みコマンド を参照) を使って、そのジョブをジョブテーブルから削除するか、あるいは disown -h を使って、 SIGHUP を受け取らないようにマークを付けます。

シェルオプションの huponexit が shopt を使って設定されていた場合、対話的なログインシェルが終了するときに、 bash は SIGHUP を全てのジョブに送ります。

コマンドの完了を待っている間に、トラップが設定されたシグナルを bash が受け取ったとき、 そのトラップはコマンドが完了するまで実行されません。 bash が組み込みコマンドの wait を使って非同期コマンドを待っているときに、 トラップが設定されているシグナルを受け取ると、 組み込みコマンド wait は即座に復帰させられます。 この際の終了ステータスは 128 より大きい値になります。 また復帰するのはトラップが実行された直後です。


# プロンプト
対話的に動作している場合、 bash はコマンドを読む込み準備ができたときにプライマリプロンプト PS1 を表示し、コマンドを完成させるためにまだ入力が必要なときに セカンダリプロンプト PS2 を表示します。 bash ではこれらのプロンプト文字列をカスタマイズできます。
コマンド番号と履歴番号は異なるのが普通です: コマンドの履歴番号とは履歴リスト内での位置です。 履歴リストは履歴ファイルから読み込めます (後述の 履歴 を参照)。 一方、コマンド番号は、 現在のシェルのセッション中に実行された一連のコマンドの列における位置です。 この文字列がデコードされた後、さらにパラメータ展開、コマンド置換、 算術式展開、クォート削除が適用されます。
展開はシェルオプション promptvars (後述の シェルの組み込みコマンド の項にある shopt コマンドの説明を参照) の値に基づいて行われます。

# 履歴 (HISTORY)
-o history オプションを組み込みコマンドの set で有効にすると、 コマンド履歴 (command history) (以前に入力したコマンドのリスト) にアクセスできるようになります。 変数 HISTSIZE の値が、履歴リストに保存するコマンドの数になります。 過去に入力したコマンドのうち、最新 HISTSIZE 個分 (デフォルトは 500 個) のテキストが保存されます。 シェルは各コマンドを、パラメータ展開や変数展開 (前述の 展開 を参照) を行う前の形で履歴リストに格納します。 ただし、履歴展開は実行してから格納します。 履歴展開はシェル変数 HISTIGNORE と HISTCONTROL の値に従って実行されます。
起動時に、履歴は変数 HISTFILE (デフォルトは ~/.bash_history) が示すファイルの内容で初期化されます。 HISTFILE で指定されたファイルは、 HISTFILESIZE で指定された行数を越えないように、必要に応じて切り詰められます。 履歴ファイルを読み込むときに、履歴のコメント文字で始まり直後に数字が続く行は、 直前の履歴行のタイムスタンプとして解釈されます。 こうしたタイムスタンプを表示するかどうかは、変数 HISTTIMEFORMAT の値により決まります。 対話的なシェルが終了する際には、最近の $HISTSIZE 個の行が履歴リストから $HISTFILE にコピーされます。 シェルオプション histappend ( シェルの組み込みコマンド の項の shopt の説明を参照) が有効になっていると、 これらの行が履歴ファイルの末尾に追加されます。 このオプションが無効ならば、履歴ファイルは上書きされます。 HISTFILE が設定されていないか、履歴ファイルが書き込めない状態だと、 履歴は保存されません。 変数 HISTTIMEFORMAT が設定されている場合、シェルのセッションを越えて保持されるよう、 タイムスタンプが履歴のコメント文字を付けて履歴ファイルに書き込まれます。 履歴のコメント文字は、タイムスタンプをほかの履歴行と区別するために使われます。 履歴の保存を行った後には、履歴ファイルは行数が HISTFILESIZE 行を越えないように切り詰められます。 HISTFILESIZE が設定されていなければ、切り詰めは行われません。


このシェルでは、どのコマンドが履歴リストに保存されるかを制御できます。 HISTCONTROL 変数と HISTIGNORE 変数を設定すると、 シェルは入力されたコマンドの一部しか保存しなくなります。
シェルオプションの cmdhist を有効にすると、シェルは複数行に別れているコマンドの各行を 同じ履歴エントリに保存しようとします。 この際には、文法的な正しさを保つためにセミコロンが必要に応じて追加されます。 シェルオプションの lithist を有効にすると、このシェルは行の途中に セミコロンではなく改行文字を置く形でコマンドを保存します。 シェルオプションの設定と設定取り消しについては、後述の シェルの組み込みコマンド における説明を参照してください。

# シェルの組み込みコマンド
特に断らない限り、このセクションで説明されている組み込みコマンドのうち - で始まるオプションを受け付けるものは、オプションの終わりを表す -- も受け付けます。 組み込みコマンド exit は、- で始まる引き数として受け取るのに、 -- を必要としません。 そのほかの組み込みコマンドは、 受け取ると明記されているオプション以外を引き数として受け取り、 - で始まる引き数を不正なオプションをとて解釈します。 この解釈を防ぐには -- が必要です。


## cd [-L|[-P [-e]]] [dir]
カレントディレクトリを dir に変更します。 変数 HOME の値が dir のデフォルト値です。変数 CDPATH は、 dir を含むディレクトリの検索パスを定義します。 CDPATH 内では候補ディレクトリ名はコロン (:) で区切ります。 CDPATH 中に空のディレクトリ名がある場合、これはカレントディレクトリ (つまり ``.'') を意味します。 dir がスラッシュ (/) で始まる場合には、 CDPATH は使われません。 -P オプションは、シンボリックリンクを辿らないで物理的なディレクトリ構造を 使うように指示します (組み込みコマンド set の -P オプションも参照)。 -L オプションを指定すると、シンボリックリンクを辿るようになります。 -e オプションを -P オプションと同時に指定すると、ディレクトリの変更が成功した後に カレントディレクトリが判定できない場合、cd は失敗のステータスを返します。 引き数に - を指定するのは、 $OLDPWD を指定するのと同じ意味です。 CDPATH 内の空以外のディレクトリ名が使われたときや、 - が最初の引き数のときに、ディレクトリの変更が成功すると、 新しいディレクトリの絶対パス名が標準出力に書かれます。 ディレクトリの変更が成功した場合には返り値は真になり、 そうでない場合には偽になります。

## echo [-n] [arg ...]
arg を空白で区切って出力し、最後に改行を出力します。 終了ステータスは常に 0 です。 -n が指定された場合、最後の改行は出力されません。
## exit [n]
ステータス n でシェルを終了させます。 n を省略すると、 終了ステータスは最後に実行したコマンドの終了ステータスとなります。
## export [name[=word]] ...
指定された name には印が付けられ、 これ以降に実行するコマンドの環境に 自動的にエクスポートされるようになります。 name を与えなかった場合、 このシェル内でエクスポートされている全ての名前のリストが出力されます。 変数名に =word が続くと、変数の値に word が設定されます。 不正なオプションがあった場合、 name のいずれかが不正なシェル変数名であった場合を除き、 export は終了ステータス 0 を返します。

## pwd [-LP]
現在の作業ディレクトリの絶対パス名を出力します。 -P オプションが指定された場合や、組み込みコマンド set の -o physical オプションが有効になっている場合には、 シンボリックリンクを展開したパス名が出力されます。 -L オプションを使うと、 出力されるパス名にはシンボリックリンクが含まれているかもしれません。 カレントディレクトリの名前を読む際にエラーが起きたり、 不正なオプションが指定されたりしなければ、返却ステータスは 0 となります。

## shopt（要件外）（デフォルト動作あり）
シェルのオプション動作を制御する変数の値をトグルさせます。
shopt オプションのリストを以下に示します:

- **checkwinsize**
設定されている場合、bash はコマンドの実行後に毎回ウィンドウの大きさをチェックし、 必要に応じて LINES と COLUMNS の値を更新します。
- **cmdhist**
設定されている場合、 bash は複数行に分かれているコマンドの全ての行を、 同じ履歴エントリに保存しようとします。 これを使うと、複数行に分かれているコマンドの再編集が容易になります。（デフォルトで有効）
- **complete_fullquote**
        If set, bash quotes all shell metacharacters in filenames and directory names  when  performing
        completion.   If  not  set, bash removes metacharacters such as the dollar sign from the set of
        characters that will be quoted in completed filenames when these metacharacters appear in shell
        variable  references  in words to be completed.  This means that dollar signs in variable names
        that expand to directories will not be quoted; however, any dollar signs appearing in filenames
        will  not  be quoted, either.  This is active only when bash is using backslashes to quote com‐
        pleted filenames.  This variable is set by default, which is the default bash behavior in  ver‐
        sions through 4.2.
- **extquote**
設定されている場合、ダブルクォート中の ${parameter} の展開で、$'string' と $"string" のクォートが機能します。 このオプションは、デフォルトで有効です。
- **force_fignore**
設定されている場合、単語補完において、シェル変数 FIGNORE で指定されたサフィックスの単語は無視されます。 無視された単語が唯一の補完候補であったとしても無視されます。 詳しい説明については、前述の シェル変数 の FIGNORE の説明を参照してください。 このオプションは、デフォルトで有効です。
- **hostcomplete**
この変数が設定されており、かつ readline が使われている場合、bash は @ を含む単語を補完するときにホスト名補完を実行しようとします (前述の READLINE ライブラリ のセクションにおける 補完 を参照)。 これはデフォルトで有効になっています。
- **progcomp**
設定されている場合、プログラム補完機能 (前述のプログラム補完を参照) が有効になります。 このオプションはデフォルトで有効になっています。
- **promptvars**
設定されている場合、 プロンプト文字列に対して パラメータ展開、コマンド置換、算術式展開、クォート削除 が行われます。 この展開は前述の プロンプト セクションで説明した展開が行われた後に行われます。 このオプションはデフォルトで有効になっています。
- **sourcepath**
設定されている場合、組み込みコマンド source (.) は PATH の値を使って、引き数として与えられたファイルを含むディレクトリを探します。 このオプションはデフォルトで有効です。
unset [-fv] [name ...]
name それぞれについて、対応する変数や関数を削除します。 オプションが全く指定されていない場合や、 -v オプションが指定された場合は、各 name はシェル変数を参照します。 読み込み専用の変数の設定を消すことはできません。 -f が指定されている場合、各 name はシェル関数を参照し、その関数の定義が削除されます。 設定が消された変数や関数は全て、 それ以降のコマンドに渡される環境変数からも削除されます。 COMP_WORDBREAKS, RANDOM, SECONDS, LINENO, HISTCMD, FUNCNAME, GROUPS, DIRSTACK のいずれかの設定を消した場合、これらが持つ特別な特性もなくなります。 これは後で再設定しても元に戻ることはありません。 name が読み込み専用の場合以外は、 終了ステータスは真となります。

# バグ
bash は大きすぎるし、遅すぎます。

bash と昔ながらのバージョンの sh にはちょっとした違いがいくつかあります。この大部分は POSIX の仕様のせいで生じたものです。

使い方によっては、エイリアスは混乱の元になります。

シェル組み込みコマンドとシェル関数は、停止したり、実行を再開したりできません。

複合コマンドや `a ; b ; c' の形式のコマンド列は、 プロセスのサスペンドを行う際に綺麗に扱うことができません。 あるプロセスを停止すると、 シェルはコマンド列の次のコマンドを即座に実行するからです。 この問題はコマンド列を括弧の中に置いて サブシェルに実行させることで解決できます。 こうすれば、ひとまとまりのものとして停止できます。

配列変数は (まだ) エクスポートできません。

一度に 1 つのコプロセスしかアクティブにできません。
