# このドキュメントを読む人に向けて。
要件に明記されておらず、もしも仕様に含めるなら要件に書く必要があるぐらい機能として分離されていると感じたため、
bashの機能としてデフォルトで実装されているものうち、以下の文章に関する情報は削除されています。

* posix モードに関すること。特にBASH_ENV付近。
* 起動ファイル(.bashrc)等に関して。

# 書式
minishell
# 説明
minishell は、標準入力やファイルから読み込んだコマンドを実行するコマンド言語インタプリタです。
minishell は、bashをベースとしたミニマムなシェルです。

# 起動

対話的なシェルで起動します。
対話シェルとは標準入力と標準エラー出力がいずれも端末に接続されていて 、起動されたシェルのことです。
minishell が対話的に動作している場合には、 PS1 が設定されます。

# 定義
このドキュメントでは、 以下の定義を使用します。

**ブランク (blank)**
空白文字またはタブ文字
**単語 (word)**
シェルが 1 単位とみなす文字の並び。 トークン (token) とも言われます。
**名前 (name)**
英数字とアンダースコア文字だけから構成され、 かつ最初の文字が英字かアンダースコア文字である 単語。 識別子 (identifier) とも言われます。
**メタ文字 (metacharacter)**
クォートされていない場合に、単語区切りとなる文字。 以下の文字のうちのいずれかです:
```
| & ( ) < > space tab
```

**制御演算子 (control operator)**
制御機能を持つ トークン。 以下のシンボルのうちのいずれかです:
```
|| && ( ) |
不明 -> <newline>
```

# シェルの文法
単純なコマンド (Simple Commands)
単純なコマンド (simple command) とは、 変数の代入を並べたもの (これは省略可能です) の後に、 ブランク区切りの単語とリダイレクションを記述し、 最後に制御演算子を置いたものです。 最初の単語は実行するコマンドを指定します。 これは 0 番目の引き数となります。 残りの単語は起動されるコマンドに引き数として渡されます。

単純なコマンドの返り値はコマンドの終了コードですが、シグナル n を受けてコマンドが終了した場合には `128+n` となります。

パイプライン (Pipeline)


command の標準出力は command2 の標準入力にパイプで接続されます。 この接続は、 コマンドで指定したどのリダイレクションよりも先に実行されます (後述の リダイレクト を参照)。

パイプラインの返却ステータスは最後のコマンドの終了ステータスになります。

パイプライン中の各コマンドは、それぞれ別のプロセスとして (つまりサブシェル内で) 実行されます。

# リスト

リスト演算子のうち、 && と || の優先順位は同じです。

リスト 中では、コマンドの区切りとして、 セミコロンの代わりに一つ以上の改行が使われることもあります。

シェルはそれぞれのコマンドが終了するのを順番に待ちます。 返却ステータスは、最後に実行したコマンドの終了ステータスになります。

AND リストと OR リストは、それぞれ制御演算子 && と || で区切られたパイプラインの並びです。 AND リストと OR リストは左結合で実行されます。 AND リストは

`command1 && command2`

という形式であり、 command1 が終了ステータス 0 を返した場合に限り command2 が実行されます。

OR リストは

`command1 || command2`

という形式であり、 command1 が 0 以外の終了ステータスを返した場合に限り command2 が実行されます。 AND リストと OR リストの返却ステータスは、 リスト中で最後に実行されたコマンドの終了ステータスです。

# 複合コマンド (Compound Commands)
複合コマンド (compound command) を以下に示します:

* (list)
list はサブシェル内で実行されます (後述の コマンド実行環境 の項を参照)。 シェルの環境に影響を与えるような変数の代入や組み込みコマンドは、 コマンドの終了後に影響を残しません。 返却ステータスは list の終了ステータスです。

# クォート
クォート (quoting) を使うと、 特定の文字や単語が持つシェルに対する特別な意味をなくせます。 クォートを用いると、特殊文字の特殊な扱いを無効にしたり、 予約語が予約語として識別されることを防いだり、 パラメータの展開を防いだりできます。
前述の 定義 で挙げたメタ文字 (metacharacters) にはそれぞれ特殊な意味があるので、 その文字自身を表すためにはクォートしなければなりません。

シングルクォートで文字を囲むと、 クォート内部のそれぞれの文字は文字としての値を保持します。 シングルクォートの間にシングルクォートを置くことはできません。 これはバックスラッシュを前に付けても同じです。

ダブルクォートで文字を囲むとクォート内部の全ての文字は文字としての値を 保持しますが、 $, `, \ は例外となります。
$ と ` はダブルクォートの内部でも特殊な意味を失いません。 バックスラッシュの場合は、次の文字が $, `, ", \, <newline> のいずれかである場合に限り特殊な意味を失いません。 前にバックスラッシュを付ければ、 ダブルクォート文字をダブルクォートによるクォートの内部で クォートできます。

# パラメータ
パラメータ (parameter) は値を保持するためのものです。パラメータは 名前、 数字、後述の 特殊なパラメータ で挙げる特殊文字のいずれかで表現されます。シェルでの用法においては、 変数(variable) とは 名前 で表現されたパラメータです。 変数は値と 0 個以上の属性を持ちます。
パラメータに値が代入されていれば、 そのパラメータは設定 (set) されていると言われます。 空文字列も有効な値です。一度値を設定すると、組み込みコマンドの unset を使わなければ削除 (unset) できません (後述の シェルの組み込みコマンド を参照)。

変数 には、以下の構文で代入できます:

name=[value]

value が与えられなかった場合、変数には空文字列が代入されます。全ての value に対して、チルダ展開、パラメータと変数の展開、クォート除去が行われます (後述の 展開 を参照)。変数の 整数 属性が設定されている場合 (後述の シェルの組み込みコマンド を参照)、$((...)) の展開を使っていなくても value に対しての算術展開が行われます (後述の 算術式展開 を参照)。 単語の分割は行われません。 パス名展開も実行されません。 代入文は組み込みコマンドの alias, declare, typeset, export, readonly, local の引き数でも使われます。


# 特殊パラメータ
シェルはいくつかのパラメータを特別扱いします。 このようなパラメータは参照されるだけであり、 値を代入することは許されません。

?
最後に実行されたフォアグラウンドのパイプラインの 終了ステータスに展開されます。

# シェル変数から環境変数への継承
以下は指定された内容を日本語に翻訳し、Markdown形式でまとめたものです。
内容は英語のmanから抜粋したのち、chatGPTに食わせた結果です。一部違うかもしれません。

### ディレクトリ関連
- **PWD**
  現在の作業ディレクトリ。`cd` コマンドによって設定されます。
- **OLDPWD**
  以前の作業ディレクトリ。`cd` コマンドによって設定されます。
- **CDPATH**
  `cd` コマンドの検索パス。コロン区切りのディレクトリリストで構成されます。例: `.:~:/usr`。

### 履歴関連
- **HISTCMD**
  現在のコマンドの履歴番号（履歴リスト内のインデックス）。
  ※ この変数に値を代入しても無視されます。未設定の場合、特別なプロパティを失います。
- **HISTFILE**
  コマンド履歴を保存するファイル名。デフォルトは `~/.bash_history`。
  未設定の場合、シェル終了時に履歴は保存されません。
- **HISTFILESIZE**
  履歴ファイルに保存される最大行数。
  - この行数を超えた場合、古いエントリが削除されます。
  - 値が `0` の場合、ファイルは空になります。
  - 負の値または非数値の値を指定すると、履歴の削除が無効になります。
  - デフォルトは `HISTSIZE` と同じ値。
- **HISTSIZE**
  メモリ内の履歴リストに保存されるコマンド数。
  - 値が `0` の場合、履歴は保存されません。
  - 負の値を指定すると、無制限に保存されます。
  - デフォルトは `500`。

### 一時ファイル関連
- **TMPDIR**
  一時ファイルを作成するディレクトリ。設定されていればその値が使用されます。

### コマンド検索パス
- **PATH**
  コマンド検索パス。コロン区切りのディレクトリリストで構成されます。
  - 空のディレクトリ名（`::` など）はカレントディレクトリを意味します。
  - デフォルト値はシステム依存で、一般的には以下の形式になります：
    `/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin`

### プロンプト関連
- **PS1**
  プライマリプロンプトの文字列（詳細は「プロンプト設定」参照）。
  デフォルト値は `\s-\v\$ `。
- **PS2**
  セカンダリプロンプトの文字列（`PS1` と同様に展開されます）。
  デフォルト値は `> `。

# 展開
展開はコマンドラインが単語へ分割された後に (コマンドライン上で) 行われます。行われる展開は 5 種類あります:
* チルダ展開 (tilde expansion)　（やるとしたら$HOMEの展開だけ）
* パラメータと変数の展開 (parameter and variable expansion)
* パス名展開 (pathname expansion)。（*のみ）

展開の順序は次のようになります:

 1. チルダ展開
 2. パラメータ・ 変数展開
 3. パス名展開


## チルダ展開
クォートされていないチルダ (`~') で単語が頭文字だった場合、HOMEの値に置き換えます。HOME が設定されていない場合は、空文字列に置き換えます。

チルダ展開が失敗した場合には、 単語は置き換えられません。

## パラメータの展開
>  Handle environment variables ($ followed by a sequence of characters) which
 **should expand to their values**

`$' 文字があると、パラメータ展開が行われます。


## パス名展開
パラメータの展開を行った後に minishell はそれぞれの単語が * を含んでいるかどうか調べます。 この文字が見つかると、その単語は パターン とみなされ、 パターンにマッチするファイル名を アルファベット順にソートしたリストに置換されます。 マッチするファイル名が見つからなければ、その単語は変更されずにそのまま残ります。 パターンをパス名展開に使うとき、名前の先頭やスラッシュの直後の ``.'' は明示的にマッチさせなければなりません。 パス名のマッチングを行うとき、 スラッシュ文字は必ず明示的にマッチさせなければなりません。 これ以外の場合には、 ``.'' が特別扱いされることはありません。

シェル変数 GLOBIGNORE を使って、 パターン にマッチするファイル名の集合を制限できます。 GLOBIGNORE が設定されていれば、マッチするファイル名のうち GLOBIGNORE 中のパターンにもマッチしたものは、 マッチしたもののリストから取り除かれます。 ファイル名 ``.'' と ``..'' は GLOBIGNORE に空でない値が設定されていても必ず無視されます。しかし、 GLOBIGNORE に空でない値を設定するとシェルオプションの dotglob が有効になるので、 ``.'' で始まるほかのファイル名は全てマッチします。 ``.'' で始めるファイル名を無視する古い動作をさせるには、 ``.*'' を GLOBIGNORE のパターンに含めてください。 GLOBIGNORE を unset すると、 dotglob オプションは無効になります。

### パターンマッチング

パターンに含まれる文字のうち、以下の特殊パターン文字以外の文字は、 自分自身にマッチします。NUL 文字がパターン中に現われてはいけません。 バックスラッシュは直後の文字をエスケープします。 このバックスラッシュは、マッチングでは無視されます 特殊パターン文字をその文字そのものにマッチさせるためには、 クォートしなければなりません。

特殊パターン文字は以下の意味を持っています:

* *
空文字列を含む、任意の文字列にマッチします。 シェルオプション globstar が有効で、 * がパス名展開に用いられる場面では、 連続する 2 つの * だけのパターンが使われると、 その階層以下のディレクトリとそのサブディレクトリ、 そこにある全てのファイルにマッチします。 2 つ連続した * の後に / が続く場合には、 ディレクトリとそのサブディレクトリのみにマッチします。

# クォートの削除
先に処理される展開の後、クォートされていない ', " のうち、先の展開の結果でないものは全て削除されます。

# リダイレクト
シェルが解釈する特別な記法を用いると、コマンドの実行前に入出力を リダイレクト できます。またリダイレクトを使うと、 現在のシェル実行環境に対してファイルをオープンしたり クローズしたりできます。以下に示すリダイレクト演算子は、 単純なコマンド の前や途中に置くことができ、また コマンド の後に置けます。 リダイレクトは左から右へと、現われた順に処理されます。

以下の説明においては、リダイレクト演算子の最初の文字が < ならば、リダイレクトは標準入力 (ファイル・ディスクリプター 0) を参照します。 リダイレクト演算子の最初の文字が > ならば、リダイレクトは標準出力 (ファイル・ディスクリプター 1) を参照します。

以下の説明では、リダイレクト演算子の次の単語に対しては、 特に説明しない限り、 チルダ展開・パラメータ展開・クォート削除・パス名展開が行われます。 その単語が複数の単語に展開された場合はエラーになります。


bash は、 以下の表にあるようなファイル名がリダイレクトに使用されると、 それらを特別に扱います。


## 入力のリダイレクト
入力をリダイレクトすると、 word を展開した結果の名前を持つファイルがオープンされ、読み込みは標準入力 (ファイル・ディスクリプター 0) で行われます。

入力のリダイレクトは、以下の形式です:

<word

## 出力のリダイレクト
出力をリダイレクトすると、 word の展開した結果の名前を持つファイルがオープンされ、書き込みは標準出力 (ファイル・ディスクリプター 1) に行われます。 ファイルが存在しなかった場合は作成されます。 ファイルが存在した場合はサイズ 0 に切り詰められます。

出力のリダイレクトは、以下の形式です:

>word

## リダイレクトによる追加出力
この形式を使って出力のリダイレクトを行うと、 word を展開した結果の名前を持つファイルがオープンされ、標準出力 (ファイル・ディスクリプター 1) で追加されます。 ファイルが存在しなければ、新しく作られます。

追加出力は以下の形式です:

>>word


## ヒアドキュメント(Here Documents)
この形式のリダイレクトを用いると、 シェルは現在のソースから入力を読み込みます。 この読み込みは word を単独で含む行 (末尾にブランク文字があってはいけません) が現われるまで続きます。 その行までに読み込んだ行は、 コマンドの標準入力として扱われます。

ヒアドキュメントの形式を以下に示します:

```
<< word
        here-document
delimiter
```
word に対するパラメータ展開・コマンド置換・算術式展開・ パス名展開は全く行われません。 word が一部でもクォートされている場合は、 delimiter は word のクォートをほどいた結果 (クォート文字を削除した結果) となり、 ヒアドキュメントに含まれる行では展開が行われなくなります。 word がクォートされていなければ、 ヒアドキュメント中の全ての行に対して パラメータ展開が行われます。



# 単純なコマンドの展開
単純なコマンドを実行すると、シェルは以下に示す展開、リダイレクションを左から右の順で実行します。
2. リダイレクションでない単語が展開されます。 もし展開の後に残っている単語があれば、 その最初の単語がコマンド名となり、残りが引き数となります。
3. リダイレクションが前述の リダイレクト で説明したように実行されます。

コマンド名が残らなかった場合、リダイレクションは行われますが、 現在のシェル環境は影響を受けません。 リダイレクションのエラーが起きると、 コマンドは 0 でないステータスで終了します。

展開の後にコマンド名が残っている場合、後述するように実行が進行します。 そうでない場合はコマンドは終了します。 展開のいずれかがコマンド置換である場合には、 コマンドの終了ステータスは 最後に実行されたコマンド置換の終了ステータスになります。 コマンド置換が行われなかった場合には、 コマンドはステータス 0 で終了します。

# パラメータの代入
パラメータの代入は、パラメータで示したように、以下のように実行出来ます。

name=[value] ...

# コマンドの実行
コマンドが単語に分割された後に、 単純なコマンドとそれに対する引き数リスト (引き数リストは省略可能) となった場合、以下の動作が行われます。
コマンド名にスラッシュが含まれない場合、 シェルはコマンドの位置を特定しようとします。

名前が組み込みコマンドでなく、 かつスラッシュを含まない場合には、 bash は PATH の各要素を検索し、その名前の実行ファイルを含むディレクトリを探します。 探索に失敗すると、シェルはエラーメッセージを 表示して終了ステータス 127 を返します。

検索に成功したか、コマンド名に 1 つ以上のスラッシュが含まれる場合には、 シェルは指定されたプログラムを独立した実行環境で実行します。 引き数 0 には指定された名前が設定され、 コマンドに対する残りの引き数には (もしあれば) 指定された引き数が設定されます。

このファイルが実行可能フォーマットでないために実行が失敗し、 かつディレクトリでもない場合には、 このファイルは シェルスクリプト(shell script)であるとみなされます。 シェルスクリプトとは、シェルのコマンドが書かれているファイルのことです。 シェルスクリプトを実行するためにサブシェルが呼び出されます。 このサブシェルは自分自身を再初期化し、 シェルスクリプトを処理するために 新しいシェルが起動されたかのような結果になります。ただし、 親が記憶しているコマンドの位置 は子にも引き継がれます。

プログラムが #! で始まるファイルである場合、 最初の行の残りの部分はこのプログラムのインタプリタを指定します。 シェルは指定されたインタプリタをオペレーティングシステム上で実行します。 オペレーティングシステムは、この実行可能フォーマットを直接処理しません。 インタプリタに対する引き数は、 プログラムの先頭の行のインタプリタ名の後の省略可能な引き数 1 つと、 その後のプログラム名、さらに (もしあれば) その後のコマンドへの引き数から構成されます。

# コマンド実行環境
シェルは以下の要素からなる実行環境(execution environment)を持ちます:
* 起動時にそのシェルが継承したオープンされているファイル。 これは組み込みコマンド exec に与えられている リダイレクション機能で変更されます。
* ファイル作成モードのマスク。 シェルの親から継承します。
* シェルのパラメータ。環境内にある親シェルから継承します。

組み込みコマンドやシェル関数以外の単純なコマンドを実行するとき、 このコマンドは独立した実行環境内で呼び出されます。 この環境は以下の要素から成り立っています。 特に断らない限り、この値はシェルから引き継がれます。


* シェルのオープンしているファイルと、 コマンドに対するリダイレクションで指定した変更・追加を加えたもの。
* 現在の作業ディレクトリ
* ファイル作成モードのマスク
* エクスポートするシェル変数や関数と、 そのコマンドに対してエクスポートされた変数。 これらは環境で渡されます。
* シェルに捕捉されるトラップは、 そのシェルの親から継承された値に再設定されます。 そのシェルにより無視されるトラップは無視されます。
この独立の環境内で呼び出されたコマンドが、 (親である) シェルの実行環境に影響を及ぼすことはできません。

括弧でグループ化されたコマンドはサブシェル環境内で呼び出されます。 このサブシェル環境はシェル環境を複製したものです。 パイプラインの一部として起動された組み込みコマンドは、 サブシェル環境で実行されます。サブシェル環境に対して行われた変更は、 元のシェル実行環境に影響を及ぼすことはできません。

# 環境
プログラムの起動時には、 環境 (environment) と呼ばれる文字列の配列が渡されます。 これは 変数名-値 のペアからなるリストで、 変数名=値 という形になります。

単純なコマンドや関数に対する環境は、一時的に修正できます。 このような代入が影響を与えるのは、 そのコマンドが参照する環境だけです。


# 終了ステータス（明記無し）
実行したコマンドの終了ステータスは、waitpid システムコールまたはそれに相当する関数が返した値です。 終了ステータスは 0 から 255 の値を取りますが、後述するように、 125 より大きい値は特別にシェルによって使われることがあります。 シェルの組み込みコマンドや複合コマンドの終了ステータスも、 同じ範囲に限定されています。 環境によっては、シェルは仕様で決められた失敗のモードを表す 特別の値を使います。

シェルは、終了コード 0 で終了したコマンドは正常終了したとみなします。 終了コード 0 は成功を示します。 0 以外の終了コードは失敗を示します。 あるコマンドが致命的なシグナル N で終了したときには、 bash は「128+N」の値を終了ステータスに使います。

コマンドが見つからなかった場合には、 そのコマンドを実行するために生成された子プロセスが ステータス 127 を返します。 コマンドが見つかったけれど実行できなかった場合には、 ステータスは 126 です。

展開やリダイレクションの際にエラーが発生し コマンドが失敗した場合には、 0 より大きい終了ステータスが返されます。

シェルの組み込みコマンドは、 成功した場合にはステータス 0 (真) を返し、 実行中にエラーが起こった場合には 0 でない値 (偽) を返します。 組み込みコマンドは全て、正しくない使い方であることを示すのに 終了ステータス 2 を返します。

bash 自身が返す終了ステータスは、文法エラーが起きた場合を除き、 実行した最後のコマンドの終了ステータスです。 文法エラーの場合には 0 でない値が終了ステータスとなります。 後述の組み込みコマンド exit も参照してください。

# シグナル
bash が起動した外部コマンドは、 シェルが自分の親から継承した値をシグナルハンドラに設定します。 ジョブ制御が有効でないときには、非同期コマンドは、 継承したシグナルハンドラに加えて SIGINT と SIGQUIT も無視します。 コマンド置換の結果として実行されたコマンドは、 キーボードで生成されたジョブ制御シグナルを無視します。 無視されるシグナルは SIGTTIN, SIGTTOU, SIGTSTP です。

デフォルトでは、シェルは SIGHUP を受け取ると終了します。 終了する前には、シェルは実行中・停止中の全てのジョブに対して SIGHUP を再送信します。


# プロンプト
minishellはコマンドを読む込み準備ができたときにプライマリプロンプト PS1 を表示し、コマンドを完成させるためにまだ入力が必要なときに セカンダリプロンプト PS2 を表示します。
minishell ではこれらのプロンプト文字列をカスタマイズできます。


# 履歴 (HISTORY)
 変数 HISTSIZE の値が、履歴リストに保存するコマンドの数になります。 過去に入力したコマンドのうち、最新 HISTSIZE 個分 (デフォルトは 500 個) のテキストが保存されます。 シェルは各コマンドを、パラメータ展開や変数展開 (前述の 展開 を参照) を行う前の形で履歴リストに格納します。 ただし、履歴展開は実行してから格納します。 履歴展開はシェル変数 HISTIGNORE と HISTCONTROL の値に従って実行されます。
起動時に、履歴は変数 HISTFILE (デフォルトは ~/.bash_history) が示すファイルの内容で初期化されます。 HISTFILE で指定されたファイルは、 HISTFILESIZE で指定された行数を越えないように、必要に応じて切り詰められます。 対話的なシェルが終了する際には、最近の $HISTSIZE 個の行が履歴リストから $HISTFILE にコピーされます。このオプションが無効ならば、履歴ファイルは上書きされます。 HISTFILE が設定されていないか、履歴ファイルが書き込めない状態だと、 履歴は保存されません。 履歴の保存を行った後には、履歴ファイルは行数が HISTFILESIZE 行を越えないように切り詰められます。 HISTFILESIZE が設定されていなければ、切り詰めは行われません。


# シェルの組み込みコマンド
特に断らない限り、このセクションで説明されている組み込みコマンドのうち - で始まるオプションを受け付けるものは、オプションの終わりを表す -- も受け付けます。 組み込みコマンド exit は、- で始まる引き数として受け取るのに、 -- を必要としません。 そのほかの組み込みコマンドは、 受け取ると明記されているオプション以外を引き数として受け取り、 - で始まる引き数を不正なオプションをとて解釈します。 この解釈を防ぐには -- が必要です。


## cd [-L|[-P [-e]]] [dir]
カレントディレクトリを dir に変更します。
変数 HOME の値が dir のデフォルト値です。
変数 CDPATH は、 dir を含むディレクトリの検索パスを定義します。 CDPATH 内では候補ディレクトリ名はコロン (:) で区切ります。 CDPATH 中に空のディレクトリ名がある場合、これはカレントディレクトリ (つまり ``.'') を意味します。 dir がスラッシュ (/) で始まる場合には、 CDPATH は使われません。
-P オプションは、シンボリックリンクを辿らないで物理的なディレクトリ構造を 使うように指示します 。
-L オプションを指定すると、シンボリックリンクを辿るようになります。
-e オプションを -P オプションと同時に指定すると、ディレクトリの変更が成功した後に カレントディレクトリが判定できない場合、cd は失敗のステータスを返します。
引き数に - を指定するのと、$OLDPWDを指定するのは同じ意味です。 CDPATH 内の空以外のディレクトリ名が使われたときや、 - が最初の引き数のときに、ディレクトリの変更が成功すると、新しいディレクトリの絶対パス名が標準出力に書かれます。
ディレクトリの変更が成功した場合には返り値は真になり、そうでない場合には偽になります。

## echo [-n] [arg ...]
arg を空白で区切って出力し、最後に改行を出力します。
終了ステータスは常に 0 です。 `-n`オプション が指定された場合、最後の改行は出力されません。

## exit [n]
ステータス n でシェルを終了させます。 n を省略すると、 終了ステータスは最後に実行したコマンドの終了ステータスとなります。

## export [name[=word]] ...
指定された name には印が付けられ、 これ以降に実行するコマンドの環境に 自動的にエクスポートされるようになります。 name を与えなかった場合、 このシェル内でエクスポートされている全ての名前のリストが出力されます。 変数名に =word が続くと、変数の値に word が設定されます。 不正なオプションがあった場合、 name のいずれかが不正なシェル変数名であった場合を除き、 export は終了ステータス 0 を返します。

## pwd
現在の作業ディレクトリの絶対パス名を出力します。
「カレントディレクトリの名前を読む際にエラーが発生」「不正なオプションが指定」が無い限り返却ステータスは 0 となります。

## unset [name ...]
name それぞれについて、対応する変数や関数を削除します。
各 name はシェル変数を参照します。 読み込み専用の変数の設定を消すことはできません。
設定が消された変数や関数は全て、 それ以降のコマンドに渡される環境変数からも削除されます。 COMP_WORDBREAKS, RANDOM, SECONDS, LINENO, HISTCMD, FUNCNAME, GROUPS, DIRSTACK のいずれかの設定を消した場合、これらが持つ特別な特性もなくなります。 これは後で再設定しても元に戻ることはありません。
name が読み込み専用の場合以外は、 終了ステータスは真となります。

## env
環境変数のみを表示する。

# バグ
bash は大きすぎるし、遅すぎます。
そのため、bash といくつか挙動が異なる点があります。

シェル組み込みコマンドとシェル関数は、停止したり、実行を再開したりできません。

複合コマンドや `a ; b ; c' の形式のコマンド列は、 プロセスのサスペンドを行う際に綺麗に扱うことができません。 あるプロセスを停止すると、 シェルはコマンド列の次のコマンドを即座に実行するからです。 この問題はコマンド列を括弧の中に置いて サブシェルに実行させることで解決できます。 こうすれば、ひとまとまりのものとして停止できます。
